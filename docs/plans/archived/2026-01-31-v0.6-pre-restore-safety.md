# v0.6.0 Pre-Restore Safety Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Automatically backup existing files before any restore operation, preventing data loss if restore goes wrong.

**Architecture:** New `RestoreBackupManager` component follows existing Protocol pattern. Integrates into `BackupOrchestrator.execute_restore()` as a pre-step. Stores backups in `~/.local/share/dfbu/restore-backups/` with TOML manifests.

**Tech Stack:** Pure Python 3.14+ (pathlib, tomllib, tomli_w), no Qt imports in model layer.

---

## Task 1: Create RestoreBackupManagerProtocol

**Files:**
- Modify: `DFBU/gui/protocols.py` (add new Protocol class at end)
- Test: `DFBU/tests/test_restore_backup_manager.py` (create new file)

**Step 1: Write the failing test**

Create `DFBU/tests/test_restore_backup_manager.py`:

```python
#!/usr/bin/env python3
"""
Tests for RestoreBackupManager - Pre-Restore Safety Component

Description:
    Test suite for RestoreBackupManager validating pre-restore backups,
    manifest creation, and retention policy.

Author: Chris Purcell
"""

import sys
from pathlib import Path
from typing import Protocol, runtime_checkable

import pytest

sys.path.insert(0, str(Path(__file__).parent.parent / "gui"))

from protocols import RestoreBackupManagerProtocol


class TestRestoreBackupManagerProtocol:
    """Test RestoreBackupManagerProtocol interface definition."""

    def test_protocol_exists(self) -> None:
        """Test that RestoreBackupManagerProtocol is defined."""
        # Assert
        assert hasattr(RestoreBackupManagerProtocol, "backup_before_restore")
        assert hasattr(RestoreBackupManagerProtocol, "get_backup_count")
        assert hasattr(RestoreBackupManagerProtocol, "cleanup_old_backups")
```

**Step 2: Run test to verify it fails**

Run: `pytest DFBU/tests/test_restore_backup_manager.py::TestRestoreBackupManagerProtocol::test_protocol_exists -v`
Expected: FAIL with "cannot import name 'RestoreBackupManagerProtocol'"

**Step 3: Write minimal implementation**

Add to `DFBU/gui/protocols.py` at end of file:

```python
# =============================================================================
# Restore Backup Manager Protocol
# =============================================================================


class RestoreBackupManagerProtocol(Protocol):
    """
    Protocol defining interface for pre-restore backup management.

    Implementations must provide backup creation before restore operations,
    manifest tracking, and retention policy enforcement.
    """

    @property
    def backup_base_dir(self) -> Path:
        """Get base directory for restore backups."""
        ...

    @property
    def max_backups(self) -> int:
        """Get maximum number of restore backups to retain."""
        ...

    @max_backups.setter
    def max_backups(self, value: int) -> None:
        """Set maximum number of restore backups to retain."""
        ...

    def backup_before_restore(
        self,
        files_to_overwrite: list[Path],
        source_backup_path: str,
    ) -> tuple[bool, str, Path | None]:
        """
        Create backup of files that will be overwritten during restore.

        Args:
            files_to_overwrite: List of destination paths that will be overwritten
            source_backup_path: Path to the backup being restored from

        Returns:
            Tuple of (success, error_message, backup_directory)
        """
        ...

    def get_backup_count(self) -> int:
        """
        Get number of existing restore backups.

        Returns:
            Number of backup directories in backup_base_dir
        """
        ...

    def cleanup_old_backups(self) -> list[Path]:
        """
        Remove oldest backups exceeding max_backups limit.

        Returns:
            List of removed backup directory paths
        """
        ...

    def list_backups(self) -> list[tuple[Path, str]]:
        """
        List all restore backups with their timestamps.

        Returns:
            List of (backup_path, timestamp_str) tuples, newest first
        """
        ...
```

**Step 4: Run test to verify it passes**

Run: `pytest DFBU/tests/test_restore_backup_manager.py::TestRestoreBackupManagerProtocol::test_protocol_exists -v`
Expected: PASS

**Step 5: Commit**

```bash
git add DFBU/gui/protocols.py DFBU/tests/test_restore_backup_manager.py
git commit -m "feat(protocols): add RestoreBackupManagerProtocol interface"
```

---

## Task 2: Create RestoreBackupManager Class - Initialization

**Files:**
- Create: `DFBU/gui/restore_backup_manager.py`
- Test: `DFBU/tests/test_restore_backup_manager.py` (add tests)

**Step 1: Write the failing test**

Add to `DFBU/tests/test_restore_backup_manager.py`:

```python
from restore_backup_manager import RestoreBackupManager


class TestRestoreBackupManagerInitialization:
    """Test RestoreBackupManager initialization."""

    def test_initialization_default_path(self) -> None:
        """Test RestoreBackupManager initializes with default backup path."""
        # Arrange & Act
        manager = RestoreBackupManager()

        # Assert
        expected_path = Path.home() / ".local" / "share" / "dfbu" / "restore-backups"
        assert manager.backup_base_dir == expected_path
        assert manager.max_backups == 5

    def test_initialization_custom_path(self, tmp_path: Path) -> None:
        """Test RestoreBackupManager with custom backup path."""
        # Arrange
        custom_path = tmp_path / "custom-backups"

        # Act
        manager = RestoreBackupManager(backup_base_dir=custom_path, max_backups=10)

        # Assert
        assert manager.backup_base_dir == custom_path
        assert manager.max_backups == 10

    def test_max_backups_setter(self, tmp_path: Path) -> None:
        """Test max_backups can be updated."""
        # Arrange
        manager = RestoreBackupManager(backup_base_dir=tmp_path)

        # Act
        manager.max_backups = 3

        # Assert
        assert manager.max_backups == 3
```

**Step 2: Run test to verify it fails**

Run: `pytest DFBU/tests/test_restore_backup_manager.py::TestRestoreBackupManagerInitialization -v`
Expected: FAIL with "cannot import name 'RestoreBackupManager'"

**Step 3: Write minimal implementation**

Create `DFBU/gui/restore_backup_manager.py`:

```python
#!/usr/bin/env python3
"""
DFBU RestoreBackupManager - Pre-Restore Safety Component

Description:
    Manages automatic backups of files before restore operations, preventing
    data loss if a restore goes wrong. Creates timestamped backup directories
    with TOML manifests tracking what was backed up and why.

Author: Chris Purcell
Email: chris@l3digital.net
GitHub: https://github.com/L3DigitalNet
Date Created: 2026-01-31
License: MIT

Features:
    - Automatic backup before restore operations
    - TOML manifest with backup metadata
    - Configurable retention policy (default: 5 backups)
    - Directory structure preservation
    - Cleanup of old backups

Requirements:
    - Linux environment
    - Python 3.14+ for Path.copy() with metadata preservation
    - tomli_w for TOML writing
    - No Qt dependencies (pure model layer)

Classes:
    - RestoreBackupManager: Manages pre-restore backup operations
"""

import logging
from pathlib import Path
from typing import Final


# Setup logger for this module
logger = logging.getLogger(__name__)


# =============================================================================
# Constants
# =============================================================================

DEFAULT_BACKUP_DIR: Final[Path] = (
    Path.home() / ".local" / "share" / "dfbu" / "restore-backups"
)
DEFAULT_MAX_BACKUPS: Final[int] = 5


# =============================================================================
# RestoreBackupManager Class
# =============================================================================


class RestoreBackupManager:
    """
    Manages pre-restore backup operations for data safety.

    Creates timestamped backups of files before they are overwritten during
    restore operations. Maintains TOML manifests documenting what was backed
    up and enforces retention policies to limit disk usage.

    Attributes:
        backup_base_dir: Base directory for all restore backups
        max_backups: Maximum number of backups to retain

    Public methods:
        backup_before_restore: Create backup of files before restore
        get_backup_count: Get number of existing backups
        cleanup_old_backups: Remove backups exceeding retention limit
        list_backups: List all backups with timestamps
    """

    def __init__(
        self,
        backup_base_dir: Path | None = None,
        max_backups: int = DEFAULT_MAX_BACKUPS,
    ) -> None:
        """
        Initialize RestoreBackupManager.

        Args:
            backup_base_dir: Base directory for backups (default: ~/.local/share/dfbu/restore-backups)
            max_backups: Maximum backups to retain (default: 5)
        """
        self._backup_base_dir = backup_base_dir or DEFAULT_BACKUP_DIR
        self._max_backups = max_backups

    @property
    def backup_base_dir(self) -> Path:
        """Get base directory for restore backups."""
        return self._backup_base_dir

    @property
    def max_backups(self) -> int:
        """Get maximum number of restore backups to retain."""
        return self._max_backups

    @max_backups.setter
    def max_backups(self, value: int) -> None:
        """Set maximum number of restore backups to retain."""
        self._max_backups = value
```

**Step 4: Run test to verify it passes**

Run: `pytest DFBU/tests/test_restore_backup_manager.py::TestRestoreBackupManagerInitialization -v`
Expected: PASS

**Step 5: Commit**

```bash
git add DFBU/gui/restore_backup_manager.py DFBU/tests/test_restore_backup_manager.py
git commit -m "feat(restore-backup): add RestoreBackupManager initialization"
```

---

## Task 3: Implement get_backup_count and list_backups

**Files:**
- Modify: `DFBU/gui/restore_backup_manager.py`
- Test: `DFBU/tests/test_restore_backup_manager.py`

**Step 1: Write the failing tests**

Add to `DFBU/tests/test_restore_backup_manager.py`:

```python
class TestBackupListing:
    """Test backup listing and counting."""

    def test_get_backup_count_empty(self, tmp_path: Path) -> None:
        """Test count is 0 when no backups exist."""
        # Arrange
        manager = RestoreBackupManager(backup_base_dir=tmp_path)

        # Act
        count = manager.get_backup_count()

        # Assert
        assert count == 0

    def test_get_backup_count_with_backups(self, tmp_path: Path) -> None:
        """Test count matches number of backup directories."""
        # Arrange
        manager = RestoreBackupManager(backup_base_dir=tmp_path)
        (tmp_path / "2026-01-31_100000").mkdir()
        (tmp_path / "2026-01-31_110000").mkdir()
        (tmp_path / "2026-01-31_120000").mkdir()

        # Act
        count = manager.get_backup_count()

        # Assert
        assert count == 3

    def test_get_backup_count_ignores_files(self, tmp_path: Path) -> None:
        """Test count ignores regular files, only counts directories."""
        # Arrange
        manager = RestoreBackupManager(backup_base_dir=tmp_path)
        (tmp_path / "2026-01-31_100000").mkdir()
        (tmp_path / "random_file.txt").write_text("ignore me")

        # Act
        count = manager.get_backup_count()

        # Assert
        assert count == 1

    def test_list_backups_empty(self, tmp_path: Path) -> None:
        """Test list returns empty when no backups exist."""
        # Arrange
        manager = RestoreBackupManager(backup_base_dir=tmp_path)

        # Act
        backups = manager.list_backups()

        # Assert
        assert backups == []

    def test_list_backups_sorted_newest_first(self, tmp_path: Path) -> None:
        """Test list returns backups sorted by timestamp, newest first."""
        # Arrange
        manager = RestoreBackupManager(backup_base_dir=tmp_path)
        (tmp_path / "2026-01-30_100000").mkdir()
        (tmp_path / "2026-01-31_120000").mkdir()
        (tmp_path / "2026-01-31_100000").mkdir()

        # Act
        backups = manager.list_backups()

        # Assert
        assert len(backups) == 3
        assert backups[0][0].name == "2026-01-31_120000"
        assert backups[1][0].name == "2026-01-31_100000"
        assert backups[2][0].name == "2026-01-30_100000"
```

**Step 2: Run test to verify it fails**

Run: `pytest DFBU/tests/test_restore_backup_manager.py::TestBackupListing -v`
Expected: FAIL with "AttributeError: 'RestoreBackupManager' object has no attribute 'get_backup_count'"

**Step 3: Write minimal implementation**

Add to `RestoreBackupManager` class in `DFBU/gui/restore_backup_manager.py`:

```python
    def get_backup_count(self) -> int:
        """
        Get number of existing restore backups.

        Returns:
            Number of backup directories in backup_base_dir
        """
        if not self._backup_base_dir.exists():
            return 0
        return len([d for d in self._backup_base_dir.iterdir() if d.is_dir()])

    def list_backups(self) -> list[tuple[Path, str]]:
        """
        List all restore backups with their timestamps.

        Returns:
            List of (backup_path, timestamp_str) tuples, newest first
        """
        if not self._backup_base_dir.exists():
            return []

        backup_dirs = [d for d in self._backup_base_dir.iterdir() if d.is_dir()]
        # Sort by directory name (timestamp format ensures correct ordering)
        backup_dirs.sort(key=lambda d: d.name, reverse=True)

        return [(d, d.name) for d in backup_dirs]
```

**Step 4: Run test to verify it passes**

Run: `pytest DFBU/tests/test_restore_backup_manager.py::TestBackupListing -v`
Expected: PASS

**Step 5: Commit**

```bash
git add DFBU/gui/restore_backup_manager.py DFBU/tests/test_restore_backup_manager.py
git commit -m "feat(restore-backup): add get_backup_count and list_backups methods"
```

---

## Task 4: Implement cleanup_old_backups

**Files:**
- Modify: `DFBU/gui/restore_backup_manager.py`
- Test: `DFBU/tests/test_restore_backup_manager.py`

**Step 1: Write the failing tests**

Add to `DFBU/tests/test_restore_backup_manager.py`:

```python
import shutil


class TestCleanupOldBackups:
    """Test backup cleanup and retention policy."""

    def test_cleanup_no_action_under_limit(self, tmp_path: Path) -> None:
        """Test cleanup does nothing when under max_backups limit."""
        # Arrange
        manager = RestoreBackupManager(backup_base_dir=tmp_path, max_backups=5)
        (tmp_path / "2026-01-31_100000").mkdir()
        (tmp_path / "2026-01-31_110000").mkdir()

        # Act
        removed = manager.cleanup_old_backups()

        # Assert
        assert removed == []
        assert manager.get_backup_count() == 2

    def test_cleanup_removes_oldest_over_limit(self, tmp_path: Path) -> None:
        """Test cleanup removes oldest backups when over limit."""
        # Arrange
        manager = RestoreBackupManager(backup_base_dir=tmp_path, max_backups=2)
        dir1 = tmp_path / "2026-01-29_100000"
        dir2 = tmp_path / "2026-01-30_100000"
        dir3 = tmp_path / "2026-01-31_100000"
        dir1.mkdir()
        dir2.mkdir()
        dir3.mkdir()

        # Act
        removed = manager.cleanup_old_backups()

        # Assert
        assert len(removed) == 1
        assert removed[0] == dir1
        assert not dir1.exists()
        assert dir2.exists()
        assert dir3.exists()

    def test_cleanup_removes_multiple_oldest(self, tmp_path: Path) -> None:
        """Test cleanup removes multiple backups when far over limit."""
        # Arrange
        manager = RestoreBackupManager(backup_base_dir=tmp_path, max_backups=1)
        for i in range(5):
            (tmp_path / f"2026-01-{25+i:02d}_100000").mkdir()

        # Act
        removed = manager.cleanup_old_backups()

        # Assert
        assert len(removed) == 4
        assert manager.get_backup_count() == 1
        # Newest should remain
        assert (tmp_path / "2026-01-29_100000").exists()

    def test_cleanup_handles_nonexistent_dir(self, tmp_path: Path) -> None:
        """Test cleanup handles nonexistent backup directory gracefully."""
        # Arrange
        nonexistent = tmp_path / "does_not_exist"
        manager = RestoreBackupManager(backup_base_dir=nonexistent)

        # Act
        removed = manager.cleanup_old_backups()

        # Assert
        assert removed == []
```

**Step 2: Run test to verify it fails**

Run: `pytest DFBU/tests/test_restore_backup_manager.py::TestCleanupOldBackups -v`
Expected: FAIL with "AttributeError: 'RestoreBackupManager' object has no attribute 'cleanup_old_backups'"

**Step 3: Write minimal implementation**

Add to imports at top of `DFBU/gui/restore_backup_manager.py`:

```python
import shutil
```

Add to `RestoreBackupManager` class:

```python
    def cleanup_old_backups(self) -> list[Path]:
        """
        Remove oldest backups exceeding max_backups limit.

        Returns:
            List of removed backup directory paths
        """
        if not self._backup_base_dir.exists():
            return []

        # Get all backup directories sorted oldest first
        backup_dirs = [d for d in self._backup_base_dir.iterdir() if d.is_dir()]
        backup_dirs.sort(key=lambda d: d.name)  # Oldest first

        removed: list[Path] = []
        while len(backup_dirs) > self._max_backups:
            oldest = backup_dirs.pop(0)
            try:
                shutil.rmtree(oldest)
                removed.append(oldest)
                logger.info(f"Removed old restore backup: {oldest}")
            except OSError as e:
                logger.error(f"Failed to remove backup {oldest}: {e}")

        return removed
```

**Step 4: Run test to verify it passes**

Run: `pytest DFBU/tests/test_restore_backup_manager.py::TestCleanupOldBackups -v`
Expected: PASS

**Step 5: Commit**

```bash
git add DFBU/gui/restore_backup_manager.py DFBU/tests/test_restore_backup_manager.py
git commit -m "feat(restore-backup): add cleanup_old_backups with retention policy"
```

---

## Task 5: Implement backup_before_restore - Directory Creation

**Files:**
- Modify: `DFBU/gui/restore_backup_manager.py`
- Test: `DFBU/tests/test_restore_backup_manager.py`

**Step 1: Write the failing tests**

Add to `DFBU/tests/test_restore_backup_manager.py`:

```python
from datetime import datetime
import re


class TestBackupBeforeRestore:
    """Test backup_before_restore functionality."""

    def test_backup_creates_timestamped_directory(self, tmp_path: Path) -> None:
        """Test backup creates directory with timestamp name."""
        # Arrange
        manager = RestoreBackupManager(backup_base_dir=tmp_path)
        file_to_backup = tmp_path / "original" / "test.txt"
        file_to_backup.parent.mkdir()
        file_to_backup.write_text("original content")

        # Act
        success, error, backup_dir = manager.backup_before_restore(
            files_to_overwrite=[file_to_backup],
            source_backup_path="/backups/mirror/2026-01-28",
        )

        # Assert
        assert success is True
        assert error == ""
        assert backup_dir is not None
        assert backup_dir.exists()
        # Verify timestamp format: YYYY-MM-DD_HHMMSS
        assert re.match(r"\d{4}-\d{2}-\d{2}_\d{6}", backup_dir.name)

    def test_backup_creates_base_directory_if_missing(self, tmp_path: Path) -> None:
        """Test backup creates base directory if it doesn't exist."""
        # Arrange
        backup_base = tmp_path / "new" / "nested" / "backup"
        manager = RestoreBackupManager(backup_base_dir=backup_base)
        file_to_backup = tmp_path / "test.txt"
        file_to_backup.write_text("content")

        # Act
        success, error, backup_dir = manager.backup_before_restore(
            files_to_overwrite=[file_to_backup],
            source_backup_path="/backups/mirror/test",
        )

        # Assert
        assert success is True
        assert backup_base.exists()

    def test_backup_empty_list_succeeds(self, tmp_path: Path) -> None:
        """Test backup with empty file list succeeds with no backup created."""
        # Arrange
        manager = RestoreBackupManager(backup_base_dir=tmp_path)

        # Act
        success, error, backup_dir = manager.backup_before_restore(
            files_to_overwrite=[],
            source_backup_path="/backups/mirror/test",
        )

        # Assert
        assert success is True
        assert error == ""
        assert backup_dir is None
        assert manager.get_backup_count() == 0
```

**Step 2: Run test to verify it fails**

Run: `pytest DFBU/tests/test_restore_backup_manager.py::TestBackupBeforeRestore::test_backup_creates_timestamped_directory -v`
Expected: FAIL with "AttributeError: 'RestoreBackupManager' object has no attribute 'backup_before_restore'"

**Step 3: Write minimal implementation**

Add to imports at top of `DFBU/gui/restore_backup_manager.py`:

```python
from datetime import UTC, datetime
```

Add constant after existing constants:

```python
BACKUP_TIMESTAMP_FORMAT: Final[str] = "%Y-%m-%d_%H%M%S"
```

Add to `RestoreBackupManager` class:

```python
    def backup_before_restore(
        self,
        files_to_overwrite: list[Path],
        source_backup_path: str,
    ) -> tuple[bool, str, Path | None]:
        """
        Create backup of files that will be overwritten during restore.

        Args:
            files_to_overwrite: List of destination paths that will be overwritten
            source_backup_path: Path to the backup being restored from

        Returns:
            Tuple of (success, error_message, backup_directory)
        """
        # Early return if no files to backup
        if not files_to_overwrite:
            return True, "", None

        # Filter to only existing files
        existing_files = [f for f in files_to_overwrite if f.exists()]
        if not existing_files:
            return True, "", None

        # Create timestamped backup directory
        timestamp = datetime.now(UTC).strftime(BACKUP_TIMESTAMP_FORMAT)
        backup_dir = self._backup_base_dir / timestamp

        try:
            backup_dir.mkdir(parents=True, exist_ok=False)
        except FileExistsError:
            # Extremely unlikely - add milliseconds to make unique
            timestamp = f"{timestamp}_{datetime.now(UTC).microsecond:06d}"
            backup_dir = self._backup_base_dir / timestamp
            backup_dir.mkdir(parents=True)
        except OSError as e:
            return False, f"Failed to create backup directory: {e}", None

        logger.info(f"Created pre-restore backup directory: {backup_dir}")
        return True, "", backup_dir
```

**Step 4: Run test to verify it passes**

Run: `pytest DFBU/tests/test_restore_backup_manager.py::TestBackupBeforeRestore -v --tb=short`
Expected: PASS (3 tests)

**Step 5: Commit**

```bash
git add DFBU/gui/restore_backup_manager.py DFBU/tests/test_restore_backup_manager.py
git commit -m "feat(restore-backup): add backup_before_restore directory creation"
```

---

## Task 6: Implement backup_before_restore - File Copying

**Files:**
- Modify: `DFBU/gui/restore_backup_manager.py`
- Test: `DFBU/tests/test_restore_backup_manager.py`

**Step 1: Write the failing tests**

Add to `TestBackupBeforeRestore` class:

```python
    def test_backup_copies_files_preserving_structure(self, tmp_path: Path) -> None:
        """Test backup copies files preserving relative directory structure."""
        # Arrange
        manager = RestoreBackupManager(backup_base_dir=tmp_path / "backups")

        # Create source files with nested structure
        config_dir = tmp_path / "home" / ".config" / "app"
        config_dir.mkdir(parents=True)
        config_file = config_dir / "settings.toml"
        config_file.write_text("key = 'value'")

        bashrc = tmp_path / "home" / ".bashrc"
        bashrc.write_text("export PATH=$PATH")

        # Act
        success, error, backup_dir = manager.backup_before_restore(
            files_to_overwrite=[config_file, bashrc],
            source_backup_path="/backups/mirror/test",
        )

        # Assert
        assert success is True
        assert backup_dir is not None

        # Verify files were copied (structure relative to home)
        backed_up_config = backup_dir / ".config" / "app" / "settings.toml"
        backed_up_bashrc = backup_dir / ".bashrc"
        assert backed_up_config.exists()
        assert backed_up_bashrc.exists()
        assert backed_up_config.read_text() == "key = 'value'"
        assert backed_up_bashrc.read_text() == "export PATH=$PATH"

    def test_backup_skips_nonexistent_files(self, tmp_path: Path) -> None:
        """Test backup skips files that don't exist."""
        # Arrange
        manager = RestoreBackupManager(backup_base_dir=tmp_path / "backups")

        existing = tmp_path / "exists.txt"
        existing.write_text("I exist")
        nonexistent = tmp_path / "missing.txt"

        # Act
        success, error, backup_dir = manager.backup_before_restore(
            files_to_overwrite=[existing, nonexistent],
            source_backup_path="/backups/mirror/test",
        )

        # Assert
        assert success is True
        # Only the existing file should be backed up
        backed_up = backup_dir / "exists.txt"
        assert backed_up.exists()
        assert not (backup_dir / "missing.txt").exists()

    def test_backup_handles_directories(self, tmp_path: Path) -> None:
        """Test backup handles directories by copying all contents."""
        # Arrange
        manager = RestoreBackupManager(backup_base_dir=tmp_path / "backups")

        source_dir = tmp_path / "home" / ".config" / "nvim"
        source_dir.mkdir(parents=True)
        (source_dir / "init.lua").write_text("vim.opt.number = true")
        (source_dir / "lua").mkdir()
        (source_dir / "lua" / "plugins.lua").write_text("return {}")

        # Act
        success, error, backup_dir = manager.backup_before_restore(
            files_to_overwrite=[source_dir],
            source_backup_path="/backups/mirror/test",
        )

        # Assert
        assert success is True
        backed_up_dir = backup_dir / ".config" / "nvim"
        assert backed_up_dir.is_dir()
        assert (backed_up_dir / "init.lua").read_text() == "vim.opt.number = true"
        assert (backed_up_dir / "lua" / "plugins.lua").read_text() == "return {}"
```

**Step 2: Run test to verify it fails**

Run: `pytest DFBU/tests/test_restore_backup_manager.py::TestBackupBeforeRestore::test_backup_copies_files_preserving_structure -v`
Expected: FAIL (files not being copied yet)

**Step 3: Write implementation**

Update the `backup_before_restore` method in `DFBU/gui/restore_backup_manager.py`:

```python
    def backup_before_restore(
        self,
        files_to_overwrite: list[Path],
        source_backup_path: str,
    ) -> tuple[bool, str, Path | None]:
        """
        Create backup of files that will be overwritten during restore.

        Args:
            files_to_overwrite: List of destination paths that will be overwritten
            source_backup_path: Path to the backup being restored from

        Returns:
            Tuple of (success, error_message, backup_directory)
        """
        # Early return if no files to backup
        if not files_to_overwrite:
            return True, "", None

        # Filter to only existing files/directories
        existing_paths = [f for f in files_to_overwrite if f.exists()]
        if not existing_paths:
            return True, "", None

        # Create timestamped backup directory
        timestamp = datetime.now(UTC).strftime(BACKUP_TIMESTAMP_FORMAT)
        backup_dir = self._backup_base_dir / timestamp

        try:
            backup_dir.mkdir(parents=True, exist_ok=False)
        except FileExistsError:
            # Extremely unlikely - add microseconds to make unique
            timestamp = f"{timestamp}_{datetime.now(UTC).microsecond:06d}"
            backup_dir = self._backup_base_dir / timestamp
            backup_dir.mkdir(parents=True)
        except OSError as e:
            return False, f"Failed to create backup directory: {e}", None

        logger.info(f"Created pre-restore backup directory: {backup_dir}")

        # Copy each file/directory preserving structure relative to home
        home = Path.home()
        backed_up_files: list[dict[str, str]] = []

        for src_path in existing_paths:
            try:
                # Calculate relative path from home directory
                try:
                    rel_path = src_path.relative_to(home)
                except ValueError:
                    # Path not under home - use just the name
                    rel_path = Path(src_path.name)

                dest_path = backup_dir / rel_path

                if src_path.is_dir():
                    # Copy directory recursively
                    shutil.copytree(src_path, dest_path)
                    logger.debug(f"Backed up directory: {src_path} -> {dest_path}")
                else:
                    # Create parent directories and copy file
                    dest_path.parent.mkdir(parents=True, exist_ok=True)
                    shutil.copy2(src_path, dest_path)
                    logger.debug(f"Backed up file: {src_path} -> {dest_path}")

                backed_up_files.append({
                    "original_path": str(src_path),
                    "backup_path": str(rel_path),
                    "size_bytes": src_path.stat().st_size if src_path.is_file() else 0,
                })

            except OSError as e:
                logger.error(f"Failed to backup {src_path}: {e}")
                # Continue with other files even if one fails

        return True, "", backup_dir
```

**Step 4: Run test to verify it passes**

Run: `pytest DFBU/tests/test_restore_backup_manager.py::TestBackupBeforeRestore -v`
Expected: PASS (6 tests)

**Step 5: Commit**

```bash
git add DFBU/gui/restore_backup_manager.py DFBU/tests/test_restore_backup_manager.py
git commit -m "feat(restore-backup): implement file copying with structure preservation"
```

---

## Task 7: Implement Manifest Creation

**Files:**
- Modify: `DFBU/gui/restore_backup_manager.py`
- Test: `DFBU/tests/test_restore_backup_manager.py`

**Step 1: Write the failing tests**

Add to `TestBackupBeforeRestore` class:

```python
import tomllib


class TestManifestCreation:
    """Test manifest.toml creation."""

    def test_backup_creates_manifest(self, tmp_path: Path) -> None:
        """Test backup creates manifest.toml with metadata."""
        # Arrange
        manager = RestoreBackupManager(backup_base_dir=tmp_path / "backups")

        test_file = tmp_path / "home" / ".bashrc"
        test_file.parent.mkdir(parents=True)
        test_file.write_text("# bash config")

        # Act
        success, error, backup_dir = manager.backup_before_restore(
            files_to_overwrite=[test_file],
            source_backup_path="/backups/mirror/2026-01-28",
        )

        # Assert
        manifest_path = backup_dir / "manifest.toml"
        assert manifest_path.exists()

        with open(manifest_path, "rb") as f:
            manifest = tomllib.load(f)

        assert "restore_operation" in manifest
        assert manifest["restore_operation"]["source_backup"] == "/backups/mirror/2026-01-28"
        assert manifest["restore_operation"]["file_count"] == 1
        assert "timestamp" in manifest["restore_operation"]
        assert "hostname" in manifest["restore_operation"]

    def test_manifest_includes_backed_up_files(self, tmp_path: Path) -> None:
        """Test manifest lists all backed up files."""
        # Arrange
        manager = RestoreBackupManager(backup_base_dir=tmp_path / "backups")

        file1 = tmp_path / "home" / ".bashrc"
        file2 = tmp_path / "home" / ".zshrc"
        file1.parent.mkdir(parents=True)
        file1.write_text("bash")
        file2.write_text("zsh")

        # Act
        success, error, backup_dir = manager.backup_before_restore(
            files_to_overwrite=[file1, file2],
            source_backup_path="/backups/test",
        )

        # Assert
        with open(backup_dir / "manifest.toml", "rb") as f:
            manifest = tomllib.load(f)

        assert "backed_up_files" in manifest
        assert len(manifest["backed_up_files"]) == 2

        paths = [f["original_path"] for f in manifest["backed_up_files"]]
        assert str(file1) in paths
        assert str(file2) in paths
```

**Step 2: Run test to verify it fails**

Run: `pytest DFBU/tests/test_restore_backup_manager.py::TestManifestCreation -v`
Expected: FAIL with "manifest.toml does not exist"

**Step 3: Write implementation**

Add imports at top of `DFBU/gui/restore_backup_manager.py`:

```python
import socket
import tomli_w
```

Update `backup_before_restore` to create manifest at the end (add after the file copy loop, before the return):

```python
        # Create manifest.toml documenting the backup
        manifest = {
            "restore_operation": {
                "timestamp": datetime.now(UTC).isoformat(),
                "source_backup": source_backup_path,
                "hostname": socket.gethostname(),
                "file_count": len(backed_up_files),
            },
            "backed_up_files": backed_up_files,
        }

        manifest_path = backup_dir / "manifest.toml"
        try:
            with open(manifest_path, "wb") as f:
                tomli_w.dump(manifest, f)
            logger.info(f"Created backup manifest: {manifest_path}")
        except OSError as e:
            logger.error(f"Failed to write manifest: {e}")
            # Backup still succeeded even if manifest failed

        return True, "", backup_dir
```

**Step 4: Run test to verify it passes**

Run: `pytest DFBU/tests/test_restore_backup_manager.py::TestManifestCreation -v`
Expected: PASS

**Step 5: Commit**

```bash
git add DFBU/gui/restore_backup_manager.py DFBU/tests/test_restore_backup_manager.py
git commit -m "feat(restore-backup): add TOML manifest creation"
```

---

## Task 8: Integrate with BackupOrchestrator

**Files:**
- Modify: `DFBU/gui/backup_orchestrator.py`
- Test: `DFBU/tests/test_backup_orchestrator.py`

**Step 1: Write the failing tests**

Add to `DFBU/tests/test_backup_orchestrator.py`:

```python
class TestRestoreWithPreBackup:
    """Test restore operation with pre-restore backup."""

    def test_restore_calls_pre_backup(self, tmp_path: Path) -> None:
        """Test restore calls RestoreBackupManager before restoring."""
        # Arrange
        file_ops = Mock(spec=FileOperations)
        stats_tracker = Mock(spec=StatisticsTracker)
        restore_backup_mgr = Mock()
        restore_backup_mgr.backup_before_restore.return_value = (True, "", tmp_path / "backup")

        # Setup source files
        src_dir = tmp_path / "backup"
        src_dir.mkdir()
        (src_dir / "test.txt").write_text("content")

        file_ops.discover_restore_files.return_value = [src_dir / "test.txt"]
        file_ops.reconstruct_restore_paths.return_value = [
            (src_dir / "test.txt", Path.home() / ".test.txt")
        ]
        file_ops.copy_file.return_value = True

        orchestrator = BackupOrchestrator(
            file_ops, stats_tracker, tmp_path, tmp_path,
            restore_backup_manager=restore_backup_mgr,
        )

        # Act
        orchestrator.execute_restore(src_dir)

        # Assert
        restore_backup_mgr.backup_before_restore.assert_called_once()

    def test_restore_aborts_if_pre_backup_fails(self, tmp_path: Path) -> None:
        """Test restore aborts if pre-backup fails."""
        # Arrange
        file_ops = Mock(spec=FileOperations)
        stats_tracker = Mock(spec=StatisticsTracker)
        restore_backup_mgr = Mock()
        restore_backup_mgr.backup_before_restore.return_value = (
            False, "Disk full", None
        )

        src_dir = tmp_path / "backup"
        src_dir.mkdir()
        (src_dir / "test.txt").write_text("content")

        file_ops.discover_restore_files.return_value = [src_dir / "test.txt"]
        file_ops.reconstruct_restore_paths.return_value = [
            (src_dir / "test.txt", Path.home() / ".test.txt")
        ]

        orchestrator = BackupOrchestrator(
            file_ops, stats_tracker, tmp_path, tmp_path,
            restore_backup_manager=restore_backup_mgr,
        )

        # Act
        processed, total = orchestrator.execute_restore(src_dir)

        # Assert
        assert processed == 0
        file_ops.copy_file.assert_not_called()

    def test_restore_works_without_backup_manager(self, tmp_path: Path) -> None:
        """Test restore still works when no backup manager provided."""
        # Arrange
        file_ops = Mock(spec=FileOperations)
        stats_tracker = Mock(spec=StatisticsTracker)

        src_dir = tmp_path / "backup"
        src_dir.mkdir()
        (src_dir / "test.txt").write_text("content")

        file_ops.discover_restore_files.return_value = [src_dir / "test.txt"]
        file_ops.reconstruct_restore_paths.return_value = [
            (src_dir / "test.txt", tmp_path / ".test.txt")
        ]
        file_ops.copy_file.return_value = True

        # No restore_backup_manager provided
        orchestrator = BackupOrchestrator(
            file_ops, stats_tracker, tmp_path, tmp_path
        )

        # Act
        processed, total = orchestrator.execute_restore(src_dir)

        # Assert
        assert processed == 1
        file_ops.copy_file.assert_called_once()
```

**Step 2: Run test to verify it fails**

Run: `pytest DFBU/tests/test_backup_orchestrator.py::TestRestoreWithPreBackup -v`
Expected: FAIL with "unexpected keyword argument 'restore_backup_manager'"

**Step 3: Write implementation**

Update `DFBU/gui/backup_orchestrator.py`:

1. Add import at top (in TYPE_CHECKING block):
```python
if TYPE_CHECKING:
    from file_operations import FileOperations
    from statistics_tracker import StatisticsTracker
    from restore_backup_manager import RestoreBackupManager
```

2. Update `__init__` signature:
```python
    def __init__(
        self,
        file_ops: FileOperations,
        stats_tracker: StatisticsTracker,
        mirror_base_dir: Path,
        archive_base_dir: Path,
        restore_backup_manager: RestoreBackupManager | None = None,
    ) -> None:
        """
        Initialize BackupOrchestrator.

        Args:
            file_ops: FileOperations instance
            stats_tracker: StatisticsTracker instance
            mirror_base_dir: Base directory for mirror backups
            archive_base_dir: Base directory for archive backups
            restore_backup_manager: Optional RestoreBackupManager for pre-restore backups
        """
        self.file_ops = file_ops
        self.stats_tracker = stats_tracker
        self.mirror_base_dir = mirror_base_dir
        self.archive_base_dir = archive_base_dir
        self._restore_backup_manager = restore_backup_manager
```

3. Update `execute_restore` method to call pre-backup:
```python
    def execute_restore(
        self,
        src_dir: Path,
        progress_callback: Callable[[int], None] | None = None,
        item_processed_callback: Callable[[str, str], None] | None = None,
    ) -> tuple[int, int]:
        """
        Execute restore operation from backup directory.

        Args:
            src_dir: Source backup directory
            progress_callback: Optional callback for progress updates (percent)
            item_processed_callback: Optional callback for processed items (src, dest)

        Returns:
            Tuple of (successful_items, total_items)
        """
        # Discover all files in backup directory recursively
        src_files = self.file_ops.discover_restore_files(src_dir)
        total_items = len(src_files)

        # Return early if no files found in backup
        if total_items == 0:
            return 0, 0

        # Reconstruct original filesystem paths from backup structure
        restore_paths = self.file_ops.reconstruct_restore_paths(src_files)

        # Pre-restore backup: backup files that will be overwritten
        if self._restore_backup_manager is not None:
            dest_paths = [dest for _, dest in restore_paths if dest is not None]
            success, error, _ = self._restore_backup_manager.backup_before_restore(
                files_to_overwrite=dest_paths,
                source_backup_path=str(src_dir),
            )
            if not success:
                logger.error(f"Pre-restore backup failed: {error}")
                return 0, total_items

        # Initialize counter for successful restore operations
        processed_count = 0

        # Copy each file from backup to original location
        for src_path, dest_path in restore_paths:
            # Skip if path reconstruction failed
            if dest_path is None:
                continue

            # Copy file with metadata preservation
            success = self.file_ops.copy_file(
                src_path, dest_path, create_parent=True, skip_identical=False
            )

            # Track restore statistics and notify callbacks
            if success:
                processed_count += 1
                self.stats_tracker.record_item_processed(0.0)
                if item_processed_callback:
                    item_processed_callback(str(src_path), str(dest_path))
            else:
                self.stats_tracker.record_item_failed()

            # Update progress callback with percentage completed
            if progress_callback and total_items > 0:
                progress = int((processed_count / total_items) * 100)
                progress_callback(progress)

        return processed_count, total_items
```

**Step 4: Run test to verify it passes**

Run: `pytest DFBU/tests/test_backup_orchestrator.py::TestRestoreWithPreBackup -v`
Expected: PASS

**Step 5: Commit**

```bash
git add DFBU/gui/backup_orchestrator.py DFBU/tests/test_backup_orchestrator.py
git commit -m "feat(orchestrator): integrate RestoreBackupManager into restore flow"
```

---

## Task 9: Add Config Options to OptionsDict

**Files:**
- Modify: `DFBU/core/common_types.py`
- Test: `DFBU/tests/test_config_validation.py`

**Step 1: Write the failing test**

Add to `DFBU/tests/test_config_validation.py`:

```python
class TestPreRestoreOptions:
    """Test pre-restore backup options in OptionsDict."""

    def test_options_dict_includes_pre_restore_backup(self) -> None:
        """Test OptionsDict includes pre_restore_backup field."""
        # Arrange
        from core.common_types import OptionsDict

        # Act
        options: OptionsDict = {
            "mirror": True,
            "archive": True,
            "hostname_subdir": True,
            "date_subdir": False,
            "archive_format": "tar.gz",
            "archive_compression_level": 5,
            "rotate_archives": True,
            "max_archives": 5,
            "pre_restore_backup": True,
            "max_restore_backups": 5,
        }

        # Assert
        assert options["pre_restore_backup"] is True
        assert options["max_restore_backups"] == 5
```

**Step 2: Run test to verify it fails**

Run: `pytest DFBU/tests/test_config_validation.py::TestPreRestoreOptions -v`
Expected: FAIL with TypedDict key error

**Step 3: Write implementation**

Update `DFBU/core/common_types.py` - add to `OptionsDict`:

```python
class OptionsDict(TypedDict):
    """
    Type definition for backup options configuration dictionary.

    Contains all backup operation settings and preferences from TOML
    configuration file.
    """

    mirror: bool
    archive: bool
    hostname_subdir: bool
    date_subdir: bool
    archive_format: str
    archive_compression_level: int
    rotate_archives: bool
    max_archives: int
    pre_restore_backup: bool
    max_restore_backups: int
```

**Step 4: Run test to verify it passes**

Run: `pytest DFBU/tests/test_config_validation.py::TestPreRestoreOptions -v`
Expected: PASS

**Step 5: Commit**

```bash
git add DFBU/core/common_types.py DFBU/tests/test_config_validation.py
git commit -m "feat(types): add pre_restore_backup options to OptionsDict"
```

---

## Task 10: Wire Up in DFBUModel

**Files:**
- Modify: `DFBU/gui/model.py`
- Test: `DFBU/tests/test_model.py`

**Step 1: Write the failing test**

Add to `DFBU/tests/test_model.py`:

```python
class TestModelRestoreBackupIntegration:
    """Test DFBUModel integration with RestoreBackupManager."""

    def test_model_has_restore_backup_manager(self) -> None:
        """Test DFBUModel creates RestoreBackupManager."""
        # Arrange & Act
        from model import DFBUModel
        model = DFBUModel()

        # Assert
        assert hasattr(model, "_restore_backup_manager")
        assert model._restore_backup_manager is not None
```

**Step 2: Run test to verify it fails**

Run: `pytest DFBU/tests/test_model.py::TestModelRestoreBackupIntegration -v`
Expected: FAIL with "has no attribute '_restore_backup_manager'"

**Step 3: Write implementation**

Update `DFBU/gui/model.py`:

1. Add import:
```python
from restore_backup_manager import RestoreBackupManager
```

2. In `__init__`, create the RestoreBackupManager and pass to orchestrator:
```python
        # Initialize pre-restore backup manager
        self._restore_backup_manager = RestoreBackupManager()

        # Initialize backup orchestrator with restore backup manager
        self._backup_orchestrator = BackupOrchestrator(
            self._file_ops,
            self._stats_tracker,
            self._config_manager.mirror_base_dir,
            self._config_manager.archive_base_dir,
            restore_backup_manager=self._restore_backup_manager,
        )
```

**Step 4: Run test to verify it passes**

Run: `pytest DFBU/tests/test_model.py::TestModelRestoreBackupIntegration -v`
Expected: PASS

**Step 5: Commit**

```bash
git add DFBU/gui/model.py DFBU/tests/test_model.py
git commit -m "feat(model): wire RestoreBackupManager into DFBUModel"
```

---

## Task 11: Update ConfigManager for New Options

**Files:**
- Modify: `DFBU/gui/config_manager.py`
- Test: `DFBU/tests/test_config_validation.py`

**Step 1: Write the failing test**

Add to `DFBU/tests/test_config_validation.py`:

```python
class TestConfigManagerPreRestoreOptions:
    """Test ConfigManager handles pre-restore options."""

    def test_load_config_defaults_pre_restore_options(self, tmp_path: Path) -> None:
        """Test loading config without pre-restore options uses defaults."""
        # Arrange
        config_content = """
[paths]
mirror_dir = "~/backups/mirror"
archive_dir = "~/backups/archive"

[options]
mirror = true
archive = true
hostname_subdir = true
date_subdir = false
archive_format = "tar.gz"
archive_compression_level = 5
rotate_archives = true
max_archives = 5
"""
        config_path = tmp_path / "config.toml"
        config_path.write_text(config_content)

        from config_manager import ConfigManager
        manager = ConfigManager(config_path)

        # Act
        success, error = manager.load_config()

        # Assert
        assert success is True
        assert manager.options["pre_restore_backup"] is True  # Default
        assert manager.options["max_restore_backups"] == 5  # Default
```

**Step 2: Run test to verify it fails**

Run: `pytest DFBU/tests/test_config_validation.py::TestConfigManagerPreRestoreOptions -v`
Expected: FAIL with KeyError for pre_restore_backup

**Step 3: Write implementation**

Update `DFBU/gui/config_manager.py` in the `load_config` method where options are processed, add defaults:

```python
        # Apply defaults for pre-restore backup options (v0.6.0)
        if "pre_restore_backup" not in self._options:
            self._options["pre_restore_backup"] = True
        if "max_restore_backups" not in self._options:
            self._options["max_restore_backups"] = 5
```

**Step 4: Run test to verify it passes**

Run: `pytest DFBU/tests/test_config_validation.py::TestConfigManagerPreRestoreOptions -v`
Expected: PASS

**Step 5: Commit**

```bash
git add DFBU/gui/config_manager.py DFBU/tests/test_config_validation.py
git commit -m "feat(config): add defaults for pre_restore_backup options"
```

---

## Task 12: Run Full Test Suite & Final Commit

**Files:**
- All modified files

**Step 1: Run full test suite**

Run: `pytest DFBU/tests/test_restore_backup_manager.py DFBU/tests/test_backup_orchestrator.py DFBU/tests/test_model.py DFBU/tests/test_config_validation.py -v`
Expected: All tests PASS

**Step 2: Run type checker**

Run: `mypy DFBU/gui/restore_backup_manager.py DFBU/gui/backup_orchestrator.py`
Expected: No errors

**Step 3: Verify feature works end-to-end**

Manual test:
1. Run `python DFBU/dfbu-gui.py`
2. Load a config with dotfiles
3. Perform a restore operation
4. Check `~/.local/share/dfbu/restore-backups/` for backup directory
5. Verify manifest.toml exists with correct content

**Step 4: Final commit**

```bash
git add -A
git commit -m "feat(v0.6.0): complete pre-restore safety implementation

- Add RestoreBackupManager component with Protocol interface
- Automatic backup before restore operations
- TOML manifest tracking backup metadata
- Configurable retention policy (default: 5 backups)
- Integrated into BackupOrchestrator restore flow
- New config options: pre_restore_backup, max_restore_backups
- Comprehensive test coverage"
```

---

## Summary

| Task | Component | Tests |
|------|-----------|-------|
| 1 | RestoreBackupManagerProtocol | 1 |
| 2 | RestoreBackupManager init | 3 |
| 3 | get_backup_count, list_backups | 5 |
| 4 | cleanup_old_backups | 4 |
| 5 | backup_before_restore (dirs) | 3 |
| 6 | backup_before_restore (files) | 3 |
| 7 | Manifest creation | 2 |
| 8 | BackupOrchestrator integration | 3 |
| 9 | OptionsDict updates | 1 |
| 10 | DFBUModel wiring | 1 |
| 11 | ConfigManager defaults | 1 |
| 12 | Full test suite | - |

**Total new tests:** ~27
**New files:** 2 (`restore_backup_manager.py`, `test_restore_backup_manager.py`)
**Modified files:** 6 (`protocols.py`, `backup_orchestrator.py`, `model.py`, `config_manager.py`, `common_types.py`, `test_backup_orchestrator.py`)
